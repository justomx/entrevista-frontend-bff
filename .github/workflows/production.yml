name: Deploy Production

on:
  release:
    types: [published]

env:
  REPO_NAME: ${{ github.event.repository.name }}

jobs:
  # slack notification
  slack-notification:
    name: Slack Notification
    runs-on: ubuntu-latest
    outputs:
      slack-result: ${{ steps.slack-notify.outputs.slack-result }}
    steps:
      # Slack notification
      - name: tag release
        env:
          TAG: ${{ github.ref }}
        run: |
          TAG_RELEASE=${TAG#*/*/}
          echo TAG_RELEASE=$TAG_RELEASE >> $GITHUB_ENV

      - name: Slack Notification
        id: slack-notify
        env:
          AS_WORKFLOW: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
          AS_RELEASE_NOTES: '${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ env.TAG_RELEASE }}'
        uses: archive/github-actions-slack@v2.7.0
        with:
          slack-bot-user-oauth-access-token: ${{ secrets.SLACK_BOT_USER_OAUTH_ACCESS_TOKEN }}
          slack-channel: G0158MWPK8E
          slack-blocks: '[{ "type": "divider" }]'
          slack-optional-attachments: |
            [{
              color: 'warning',
              type: 'mrkdwn',
              text: 'Starting <${{ env.AS_WORKFLOW }}|${{ github.workflow }}> [<${{ env.AS_RELEASE_NOTES }}|${{ env.TAG_RELEASE }}>]\nof *${{ github.repository }}*\nby: ${{ github.actor }}'
            }]

  # Deployment
  deploy-production:
    name: deploy production
    needs: slack-notification
    runs-on: ubuntu-latest
    steps:
      # Checkout
      - name: Checkout
        uses: actions/checkout@v3

      # generate tag release
      - name: tag release
        env:
          TAG: ${{ github.ref }}
        run: |
          TAG_RELEASE=${TAG#*/*/}
          echo TAG_RELEASE=$TAG_RELEASE >> $GITHUB_ENV

      # Get job URL
      - name: get job url
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          JOB_URL=`gh api /repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs | jq --raw-output '.jobs[] | select(.name == "deploy production").html_url'`
          echo JOB_URL=$JOB_URL >> $GITHUB_ENV

      # Setup AWS CLI
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.PROD_AWS_KEY }}
          aws-secret-access-key: ${{ secrets.PROD_AWS_SECRET }}
          aws-region: ${{ vars.PROD_AWS_REGION }}

      # Configure docker to use aws credentials
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      # tag image
      - name: tag image
        run: |
          MANIFEST=$(aws ecr batch-get-image --repository-name microservices --image-ids imageTag=${{ env.REPO_NAME }}-${{ github.sha }} --query 'images[].imageManifest' --output text)
          aws ecr batch-delete-image --repository-name microservices --image-ids imageTag=${{ env.TAG_RELEASE }}
          aws ecr put-image --repository-name microservices --image-tag ${{ env.TAG_RELEASE }} --image-manifest "$MANIFEST"
          aws ecr batch-delete-image --repository-name microservices --image-ids imageTag=${{ env.REPO_NAME }}-latest
          aws ecr put-image --repository-name microservices --image-tag ${{ env.REPO_NAME }}-latest --image-manifest "$MANIFEST"

      # Deploy to kubernetes
      - name: Deploy ${{ env.REPO_NAME }}
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          aws eks update-kubeconfig --name ${{ vars.PROD_AWS_CLUSTER_NAME }}

          echo "[-] Add justomx helm-charts repository"
          helm repo add justomx ${{ vars.HELM_CHARTS_URL }}
          helm repo update
          echo "[-] Install or upgrade ${{ env.REPO_NAME }} microservice"
          helm upgrade --install ${{ env.REPO_NAME }} justomx/nodejs \
          --values helm/values.production.yaml \
          --set image.repository=${{ env.ECR_REGISTRY }}/microservices \
          --set image.tag=${{ env.REPO_NAME }}-${{ github.sha }} \
          --set version=${{ env.TAG_RELEASE }} \
          --namespace ${{ vars.MS_NAMESPACE }}

      # Slack notifications
      - name: Slack Notification
        if: always()
        uses: archive/github-actions-slack@v2.7.0
        with:
          slack-function: send-message
          slack-bot-user-oauth-access-token: ${{ secrets.SLACK_BOT_USER_OAUTH_ACCESS_TOKEN }}
          slack-channel: ${{ fromJson(needs.slack-notification.outputs.slack-result).response.channel }}
          slack-optional-thread_ts: ${{ fromJson(needs.slack-notification.outputs.slack-result).response.message.ts }}
          slack-blocks: '[{ "type": "divider" }]'
          slack-optional-attachments: >-
            [{
              color: "${{ job.status == 'success' && 'good' || 'danger' }}",
              type: 'mrkdwn',
              text: "${{ github.workflow }} (<${{ env.JOB_URL }}|PROD>) [${{ env.TAG_RELEASE }}] *${{ job.status }}*",
            }]

  # finish notification
  slack-finish:
    needs: [slack-notification, deploy-production]
    runs-on: ubuntu-latest
    name: finish notification
    if: ${{ always() || contains(needs.deploy-production.result, 'failure') }}
    steps:
      - name: modify message
        uses: archive/github-actions-slack@v2.7.0
        with:
          slack-function: update-message
          slack-bot-user-oauth-access-token: ${{ secrets.SLACK_BOT_USER_OAUTH_ACCESS_TOKEN }}
          slack-channel: ${{ fromJson(needs.slack-notification.outputs.slack-result).response.channel }}
          slack-update-message-ts: ${{ fromJson(needs.slack-notification.outputs.slack-result).response.message.ts }}
          slack-update-message-blocks: >-
            [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "${{ contains(needs.*.result, 'failure') && ':x:' || ':large_green_circle:' }} Deployment *${{ needs.deploy-production.result }}* :point_down::skin-tone-4:"
                }
              },
              {
                "type": "divider"
              }
            ]
